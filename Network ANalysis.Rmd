---
title: "Network analysis"
author: "Angelo Capasso"
date: "2025-05-31"
output: html_document
---

```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(stringr)
library(tm)
library(plotly)
library(ggplot2)
library(igraph)
library(tidyverse)
library(igraph)
library(tidygraph)
library(ggraph)
library(tidyr)

df_new_comments = read.csv("nutrition_comments_cleaned.csv")
df_new_threads = read.csv("nutrition_threads_cleaned.csv")
```

dataframe unito per thread e comments
```{r}
# Crea una copia di df_new_comments
df_result <- df_new_comments %>%
  mutate(
    threads_text = df_new_threads$Cleaned_Text[thread],
    title = df_new_threads$title[thread],
    threads_score = df_new_threads$score[thread]
  )
df_result
```


1) RELAZIONI TRA AUTORI (ONE MODE)

Autori che interagiscono tra loro nei commenti
PROVATE CON DIVERSI PACCHETTI PER LE RETI:gggraph visNetwork Networkd3 ecc.
```{r}
# Pulisci i commenti: rimuovi [deleted] e crea il "gruppo" della conversazione
df_clean <- df_new_comments %>%
  filter(author != "[deleted]") %>%
  mutate(comment_group = sub("_.*", "", comment_id))  # es. da "2_1_3" ottieni "2"

# Costruisci le coppie autore-autore per ogni gruppo thread+comment_group
co_commenters <- df_clean %>%
  select(thread, comment_group, author) %>%
  distinct() %>%
  group_by(thread, comment_group) %>%
  filter(n_distinct(author) > 1) %>%
  summarise(pairs = list(as.data.frame(t(combn(sort(unique(author)), 2)))), .groups = "drop") %>%
  unnest(pairs) %>%
  rename(Source = V1, Target = V2) %>%
  group_by(Source, Target) %>%
  summarise(weight = n(), .groups = "drop")

# Esporta per Gephi
write.csv(co_commenters, "comment_network_edges.csv", row.names = FALSE)

# Nodi
nodes <- unique(c(co_commenters$Source, co_commenters$Target))
nodes_df <- data.frame(Source = nodes, Target = nodes)
write.csv(nodes_df, "authors_network_nodes.csv", row.names = FALSE)

```

```{r}
# Filtra archi per peso
filtered_edges <- co_commenters %>% filter(weight >= 5)

# Crea grafo
g <- graph_from_data_frame(filtered_edges, directed = FALSE)

# Ricalcola layout
layout <- layout_with_fr(g)
layout_df <- as.data.frame(layout)
colnames(layout_df) <- c("x", "y")
layout_df$label <- V(g)$name
deg <- degree(g)
layout_df$size <- scales::rescale(deg, to = c(5, 15))  # dimensione proporzionale

# Edges
edges <- get.edgelist(g, names = FALSE)
edges_df <- data.frame(
  x = layout_df$x[edges[,1]],
  y = layout_df$y[edges[,1]],
  xend = layout_df$x[edges[,2]],
  yend = layout_df$y[edges[,2]]
)

# Visualizzazione plotly
plot_ly() %>%
  add_segments(
    data = edges_df,
    x = ~x, y = ~y, xend = ~xend, yend = ~yend,
    line = list(color = 'rgba(150,150,150,0.2)', width = 0.5),
    hoverinfo = 'none',
    showlegend = FALSE
  ) %>%
  add_trace(
    data = layout_df,
    x = ~x, y = ~y,
    type = 'scatter', mode = 'markers+text',
    text = ~label,
    hoverinfo = 'text',
    marker = list(size = ~size, color = 'red', opacity = 0.8),
    textposition = 'top center'
  ) %>%
  layout(
    title = "Filtered Co-commenters Network (weight ≥ 5)",
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    plot_bgcolor = 'white'
  )

```



2) RELAZIONI TRA PAROLE (ONE MODE)

Rete parole-parole per i threads
DA FARE CON DIVERSE WINDOW SIZE
```{r}
frequenze_tdm <- colSums(tdm_df)  # tdm_df è la tua DTM che sta in Nutrition_textmining

tdm_filt <- tdm_df[, frequenze_tdm > 30]
term_term_thr = t(as.matrix(tdm_filt)) %*% as.matrix(tdm_filt)

diag(term_term_thr) = 0

adj_matrix_thr <- as.data.frame(term_term_thr)

adj_matrix_thr <- cbind(term = rownames(adj_matrix_thr), adj_matrix_thr)

library(openxlsx)

write.xlsx(adj_matrix_thr, file = "adjacency_matrix_thr.xlsx", rowNames = FALSE)
```




3) RELAZIONI AUTORI PAROLE O AUTORI THREADS (TWO-MODE)

Autori per ogni thread
```{r}
library(dplyr)
library(tidygraph)
library(ggraph)
library(igraph)

# Aggiungi la colonna threads_score a df_result (se non l'hai ancora)
df_result <- df_result %>%
  mutate(threads_score = df_new_threads$score[thread])

# Crea i dati edge (autori-thread) filtrando per threads_score > 50
author_thread_edges <- df_result %>%
  filter(author != "[deleted]", threads_score > 150) %>%
  group_by(author, thread) %>%
  summarise(weight = n(), .groups = "drop") %>%
  arrange(desc(weight))

# Crea i nodi (autori e thread) con etichetta di gruppo
author_thread_nodes <- tibble(
  name = unique(c(author_thread_edges$author, author_thread_edges$thread)),
  group = if_else(name %in% author_thread_edges$author, "author", "thread")
)

# Crea il grafo
graph <- graph_from_data_frame(author_thread_edges, vertices = author_thread_nodes)

# Converti in tidygraph
graph_tbl <- as_tbl_graph(graph)

# Visualizza con ggraph
ggraph(graph_tbl, layout = "fr") +
  geom_edge_link(aes(width = weight), alpha = 0.6) +
  geom_node_point(aes(color = group), size = 5) +
  geom_node_text(aes(label = name), repel = TRUE, size = 3) +
  theme_void() +
  ggtitle("Network tra Autori e Thread (Score > 150)") +
  scale_edge_width(range = c(0.5, 2))

```







Relazione threads e commenti
FATELO PIU BELLO E CON NOMI AI NODI
```{r}
edges <- data.frame(from = df_new_comments$thread, to = df_new_comments$comment_id)
nodes <- unique(c(edges$from, edges$to))
graph <- graph_from_data_frame(edges, vertices = data.frame(name = nodes), directed = TRUE)

plot(graph,
     vertex.label = NA,
     vertex.size = 5,
     edge.arrow.size = 0.2,
     layout = layout_with_fr,
     main = "Network: thread → commenti")

nodes <- data.frame(name = unique(c(df_new_comments$thread, df_new_comments$comment_id)))
links <- data.frame(source = match(df_new_comments$thread, nodes$name) - 1,
                    target = match(df_new_comments$comment_id, nodes$name) - 1,
                    value = 1)
```




4) ERGM